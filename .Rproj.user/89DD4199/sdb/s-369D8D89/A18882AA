{
    "collab_server" : "",
    "contents" : "#' Est prob-of-one-matrix\n#'\n#' Elements give est of prob that that the jth category will be observed in the ith group\n#'\n#' The function will XXXX\n#'\n#' @param XX The XX\n#' @return The function will XX\n#'\n#'\n#' @export\ngroupwise.category.freq.mat<-function(dat,lbls){\n  grp.nms<-levels(factor(lbls))\n  #prob-of-one-mat is groups by categories. Elems give est of prob that that the jth category will be observed in the ith group\n  p1.mat<-NULL\n  for(i in 1:length(grp.nms)) {\n    datg<-pick.out.groups(dat,lbls,c(grp.nms[i]))[[1]]\n    p1.vec<-colSums(datg)/nrow(datg) #MLE estimated probs\n    p1.mat<-rbind(p1.mat,p1.vec)\n  }\n\n  return(p1.mat)\n\n}\n\n\n#' New est prob-of-one-matrix\n#'\n#' Elements give est of prob that that the jth category will be observed in the ith group. This one can do MLE or Bayes-uniform prior estimation\n#'\n#' The function will XXXX\n#'\n#' @param XX The XX\n#' @return The function will XX\n#'\n#'\n#' @export\ngroupwise.category.freq.mat2<-function(dat, lbls, est.type=\"MLE\"){\n  grp.nms<-levels(factor(lbls))\n  #prob-of-one-mat is groups by categories. Elems give est of prob that that the jth category will be observed in the ith group\n  p1.mat<-NULL\n  for(i in 1:length(grp.nms)) {\n    datg<-pick.out.groups(dat,lbls,c(grp.nms[i]))[[1]]\n    if(est.type==\"MLE\") {\n      p1.vec<-colSums(datg)/nrow(datg) #MLE estimated probs\n    } else if(est.type==\"Bayes\") {\n      nn <- nrow(datg)\n      sm <- colSums(datg)\n      p1.vec <- (sm+1)/(nn+1+1) #Posterior mean asuming uniform prior\n    } else {\n      stop(\"Specify an estimation type. Choices: MLE or Bayes\")\n    }\n    p1.mat<-rbind(p1.mat,p1.vec)\n  }\n\n  return(p1.mat)\n\n}\n\n#' Simulate a dust sample, old version assuming cell independence\n#'\n#' Was called: simulate.sample\n#'\n#' The function will XXXX\n#'\n#' @param XX The XX\n#' @return The function will XX\n#'\n#'\n#' @export\nsimulate.dust.sample.old<-function(cat.ind.vec, num.sims, prob.of.1.mat) {\n\n  sim.grp<-array(NA,c(num.sims,length(cat.ind.vec)))\n  #print(dim(sim.grp))\n  #Naieve 0/1 prob in the cat vector fed in.\n  naieve.prob1<-sum(cat.ind.vec)/length(cat.ind.vec)\n\n  for(i in 1:length(cat.ind.vec)) {\n\n    if(cat.ind.vec[i]==0) {\n      #For 0 categories:\n      #in the prob vec for that category, randomly select an element, this will be p1 for that category in the simulation\n\n      prob.vec.for.cat<-prob.of.1.mat[,i]\n      prob1<-sample(prob.vec.for.cat,replace=T,size=1)\n\n      #Temper 100% selections from prob-vec-for-cat a bit???? They seem to occur alot\n      if(prob1==1) {\n        #print(paste(i,prob1*100))\n        prob1<-sample(c(prob1,naieve.prob1,0),replace=F,size=1,prob=c(1/3,1/3,1/3))\n        #print(paste(\"Now:\",i,prob1*100))\n      }\n      sim.cat.elem.ind.vec<-sample(c(1,0),size=num.sims,replace=T,prob=c(prob1,1-prob1))\n      #print(sim.cat.elem.ind.vec)\n    }\n\n    if(cat.ind.vec[i]==1) {\n      #For 1 categories:\n      #go to that category in the prob-of-1-mat\n      #keep only non zero percentages:\n      prob.vec.for.cat<-prob.of.1.mat[,i]\n      zero.idxs<-which(prob.vec.for.cat==0)\n\n      #CAUTION AND NOTE: This routene weights 1 categories heavily in favor of coming up 1 again. This is in keeping of what we have observed empirically so far. 02/08/2013\n      #if all probs in category are 0, make vector c(0,100,runif(1)*100) and sample from it. this will be p1\n      if(length(zero.idxs) == length(prob.vec.for.cat)) {\n        #Set, 95% of the time prob1 will come up 100% Can change later.\n        prob1<-sample(c(0,1,runif(1)),replace=F,size=1,prob=c(0.025,0.95,0.025))\n      } else { #otherwise collect non-zero vals. make vector c(non-zero-vals, 0,100, runif(1)*100)\n        prob.vec.for.cat<-prob.vec.for.cat[-zero.idxs]\n        #and sample form it; this will possibly be p1\n        prob1<-sample(c(prob.vec.for.cat,0,1,runif(1)),replace=F,size=1)\n        #Strongly weight prob1 in favor of 100% since we observe that when a category comes up 1 it is usually always 1\n        prob1<-sample(c(1,prob1),replace=F,size=1,prob=c(0.95,0.05))\n      }\n\n      sim.cat.elem.ind.vec<-sample(c(1,0),size=num.sims,replace=T,prob=c(prob1,1-prob1))\n\n    }\n\n    sim.grp[,i]<-sim.cat.elem.ind.vec\n\n  }\n\n  return(sim.grp)\n}\n",
    "created" : 1543345417093.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2802274381",
    "id" : "A18882AA",
    "lastKnownWriteTime" : 1543345694,
    "last_content_update" : 1543345694882,
    "path" : "~/latex/papers/dust/DUST PROJECT/dustproj/R/dust_simulate_sample_old.R",
    "project_path" : "R/dust_simulate_sample_old.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}